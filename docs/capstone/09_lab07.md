# Lab 07: Bootstrap Jenkins with Ansible

## Role(s) Responsible

**SysAdmin / Infra**

---

## Objectives

* Bootstrap a Jenkins server (install OpenJDK 17 + Jenkins) on the EC2 instance provisioned in Lab 06 using **Ansible**.
* Ensure Jenkins starts (Java 17), and show the `initialAdminPassword` so an operator can unlock the UI.
* Install required plugin on Jenkins server

---

## Pre-requisites

* **Lab 06** completed: Jenkins EC2 created and `jenkins_public_ip` exposed at root outputs in Terraform.
* `terraform` CLI configured to the same backend (or access to Terraform Cloud workspace runs).
* SSH private key used when provisioning (`infrastructure/id_rsa`) available locally (never commit private key).
* `ansible` installed on control host (Lab 01).
* Git access to team repo.
* Internet outbound from the Jenkins VM (for GUI/CLI plugin installs). If air-gapped, follow the offline plugin instructions below.

---

## Quick theory recap

Ansible connects over SSH to the target node (`ubuntu` user on our Ubuntu AMI), installs Java 17 and Jenkins package, ensures Jenkins is running, and then reads the unlock password at `/var/lib/jenkins/secrets/initialAdminPassword`. We intentionally stop short of auto-installing plugins via init scripts because plugin bootstrapping can fail during first-run; instead we expose the password so a human can complete the GUI unlock and install plugins 

---

## Files you'll add / edit in the repo

* `ansible/playbooks/jenkins_install_and_show_password.yml` (main playbook — provided below).
* `ansible/inventories/jenkins.ini` (inventory — created during the lab; uses Terraform output to populate IP).
* (Optional) `ansible/playbooks/plugins_install_cli.yml` — helper playbook that runs plugin installs via CLI **after** admin user exists (optional, provided below).
* Do **NOT** commit any private keys. Commit only public key if used for `aws_key_pair`.

---

## Step-by-step instructions

> These steps assume the student running this lab might be different from the person who ran earlier labs. Use your team GitHub account/SSH key.

### 0. Clone or update the repo

If you don't have the repo locally:

```bash
git clone git@github.com:<org>/<techops-capstone-teamX>.git
cd techops-capstone-teamX
```

If you already have the repo:

```bash
cd path/to/techops-capstone-teamX
git checkout main
git pull origin main
```

Create a feature branch for your work:

```bash
git checkout -b ansible-jenkins-setup
```

---

### 1. Get Jenkins public IP from your SysAdmin/IAM Engineer/Product Owner

**Option A — Terraform Cloud web UI**:

* Go to Terraform Cloud → Organization → Workspace `capstone-infra` → Runs → latest run → Outputs → copy `jenkins_public_ip`.

Put that IP into the inventory in next step.

---

### 2. Ensure your private key and permissions are correct

* Your private key (generated earlier in Lab 06) must be present locally (example path used below is `infrastructure/id_rsa`).
* Permissions:

```bash
chmod 600 infrastructure/id_rsa
```

* Confirm you can SSH (use correct user for Ubuntu AMI: `ubuntu`):

```bash
ssh -i infrastructure/id_rsa ubuntu@<jenkins_public_ip>
# if successful, exit with `exit`
```
* If you do not have the private key ask the user who ran the Lab06 to give you, put that key in your repo under `<your-repo>/infrastructure/id_rsa`

---

### 3. Create Ansible inventory

Create file `ansible/inventories/jenkins.ini` (relative paths shown assume running from repo root):

```ini
[jenkins]
<jenkins_public_ip> ansible_user=ubuntu ansible_ssh_private_key_file=.../<full_path_to>/infrastructure/id_rsa

```

Replace `<jenkins_public_ip>` with the IP you got from Terraform.

---

### 4. Add the playbook to install Jenkins and display the unlock password

Create `ansible/playbooks/jenkins_install_and_show_password.yml` with the exact content below (copy-paste):

```yaml
---
- name: Install Jenkins and display initial admin password
  hosts: jenkins
  become: yes
  vars:
    jenkins_home: /var/lib/jenkins
    java_home_path: "/usr/lib/jvm/java-17-openjdk-amd64"
    jenkins_cli_path: /tmp/jenkins-cli.jar
    jenkins_url_local: "http://localhost:8080"

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install packages required for apt over https and utils
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - software-properties-common
        state: present
        update_cache: yes

    - name: Install OpenJDK 17
      apt:
        name: openjdk-17-jdk
        state: present

    - name: Ensure JAVA_HOME is set for Jenkins
      lineinfile:
        path: /etc/default/jenkins
        regexp: '^JAVA_HOME='
        line: 'JAVA_HOME="{{ java_home_path }}"'
        create: yes
      notify: Restart Jenkins

    - name: Add Jenkins apt key
      apt_key:
        url: https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
        state: present

    - name: Add Jenkins apt repository
      apt_repository:
        repo: 'deb https://pkg.jenkins.io/debian-stable binary/'
        state: present

    - name: Update apt after adding jenkins repo
      apt:
        update_cache: yes

    - name: Install Jenkins package
      apt:
        name: jenkins
        state: present

    - name: Ensure jenkins home ownership and perms
      file:
        path: "{{ jenkins_home }}"
        state: directory
        owner: jenkins
        group: jenkins
        recurse: yes

    - name: Ensure Jenkins service is started & enabled
      service:
        name: jenkins
        state: started
        enabled: yes

    - name: Wait for Jenkins HTTP to be available locally
      wait_for:
        host: 127.0.0.1
        port: 8080
        timeout: 300
        state: started

    - name: Give Jenkins a few extra seconds to initialize
      pause:
        seconds: 8

    - name: Read initial admin password (if present)
      command: cat {{ jenkins_home }}/secrets/initialAdminPassword
      register: initial_pass_cmd
      ignore_errors: yes
      changed_when: false

    - name: Show initial admin password (if found)
      debug:
        msg: |
          === Jenkins initial admin password (if present) ===
          {{ initial_pass_cmd.stdout | default("NOT FOUND: initialAdminPassword file missing or setup already completed") }}
      when: initial_pass_cmd is defined

  handlers:
    - name: Restart Jenkins
      service:
        name: jenkins
        state: restarted
```

---

### 5. Run the playbook

From repo root:

```bash
ansible-playbook -i ansible/inventories/jenkins.ini ansible/playbooks/jenkins_install_and_show_password.yml
```

Look at the playbook output — you’ll see a `debug` message with the `initialAdminPassword` or a message that it’s not found (setup already completed or an init Groovy created admin earlier).

---

### 6. Unlock Jenkins via UI & create admin

1. Open `http://<jenkins_public_ip>:8080` in your browser.
2. Paste the `initialAdminPassword` from the playbook output and proceed.
3. Choose “Install suggested plugins” (quick).
4. Create the admin account when prompted and save credentials.

---

### 7. Install plugins

#### Manual via Jenkins UI (recommended for first-run)

* Manage Jenkins → Manage Plugins → Available → search & install required plugins (Git, Pipeline, Docker, Blue Ocean, Ansible, Credentials Binding, etc.)
* After installing, perform Safe Restart if prompted.

---

### 8. Prepare the Jenkins Node

1. Create a new playbook `ansible/playbooks/prepare_jenkins_node.yml`
2. Copy & Paste below playbook which will bootstrap the node and install all dependencies on Jenkins

   ```yml
   ---
    # ansible/playbooks/jenkins_prepare_node.yml
    # Idempotent playbook to prepare a Jenkins EC2 node with Docker, AWS CLI, and common tools.
    # Supports Debian/Ubuntu, RHEL/CentOS, and Amazon Linux.
    #
    # Usage:
    # ansible-playbook -i ansible/inventories/jenkins.ini ansible/playbooks/jenkins_prepare_node.yml

    - name: Prepare Jenkins node (Docker, AWS CLI, common tools)
    hosts: jenkins
    vars:
        awscli_version: "latest"  # Use latest to avoid version mismatch
        docker_ce_version: "24.0.7"  # Base Docker version (will append distribution suffix for Debian/Ubuntu)
        docker_compose_plugin: true
        jenkins_user: "jenkins"
        jenkins_service_name: "jenkins"
        arch_map:
        x86_64: amd64
        aarch64: arm64
        docker_compose_arch_map:
        x86_64: x86_64
        aarch64: aarch64
        awscli_zip_url: "https://awscli.amazonaws.com/awscli-exe-linux-{{ docker_compose_arch_map[ansible_architecture] | default(ansible_architecture) }}.zip"
        docker_compose_url: "https://github.com/docker/compose/releases/latest/download/docker-compose-Linux-{{ docker_compose_arch_map[ansible_architecture] | default(ansible_architecture) }}"

    pre_tasks:
        - name: Gather minimal facts
        ansible.builtin.setup:
            gather_subset:
            - '!all'
            - 'min'
        changed_when: false
        become: no

    tasks:
        # -----------------------
        # Common Packages
        # -----------------------
        - name: Install common packages (Debian/Ubuntu)
        when: ansible_os_family == 'Debian'
        apt:
            name:
            - apt-transport-https
            - ca-certificates
            - curl
            - gnupg
            - lsb-release
            - unzip
            - git
            - jq
            - build-essential
            update_cache: yes
            state: present
        become: yes

        - name: Install common packages (RHEL/CentOS)
        when: ansible_os_family == 'RedHat' and ansible_distribution != 'Amazon'
        yum:
            name:
            - curl
            - unzip
            - git
            - jq
            - python3
            - gcc
            - make
            state: present
        become: yes

        - name: Install common packages (Amazon Linux)
        when: ansible_distribution == 'Amazon'
        yum:
            name:
            - curl
            - unzip
            - git
            - jq
            - python3
            - gcc
            - make
            state: present
        become: yes

        # -----------------------
        # Docker repo + engine
        # -----------------------
        - name: Ensure docker GPG key and keyring (Debian)
        when: ansible_os_family == 'Debian'
        block:
            - name: Create /usr/share/keyrings if missing
            file:
                path: /usr/share/keyrings
                state: directory
                mode: '0755'
            become: yes

            - name: Download Docker GPG and create keyring
            command: >
                bash -lc "curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg"
            args:
                creates: /usr/share/keyrings/docker-archive-keyring.gpg
            become: yes

            - name: Add Docker apt repo
            apt_repository:
                repo: "deb [arch={{ arch_map[ansible_architecture] | default(ansible_architecture) }} signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
                filename: docker
                state: present
            notify: apt_update
            become: yes

        - name: Update apt cache (Debian)
        when: ansible_os_family == 'Debian'
        apt:
            update_cache: yes
        become: yes

        - name: Get available Docker versions (Debian)
        when: ansible_os_family == 'Debian'
        shell: apt-cache madison docker-ce | awk '{print $3}' | grep "{{ docker_ce_version }}"
        register: docker_version_check
        changed_when: false
        failed_when: false
        become: yes

        - name: Set Docker version with distribution suffix (Debian)
        set_fact:
            effective_docker_version: "{{ (docker_version_check.stdout_lines | select('match', '^5:' + docker_ce_version + '-1~ubuntu\\.' + ansible_distribution_version + '~' + ansible_distribution_release + '$') | first) | default('latest') }}"
        when: ansible_os_family == 'Debian'

        - name: Warn if falling back to latest Docker version
        debug:
            msg: "Desired Docker version {{ docker_ce_version }} not found for {{ ansible_distribution }} {{ ansible_distribution_version }}. Falling back to latest."
        when: ansible_os_family == 'Debian' and effective_docker_version == 'latest'

        - name: Add Docker repo (RHEL/CentOS)
        when: ansible_os_family == 'RedHat' and ansible_distribution != 'Amazon'
        yum_repository:
            name: docker-ce-stable
            description: Docker CE Stable - $basearch
            baseurl: "https://download.docker.com/linux/centos/{{ ansible_distribution_major_version }}/{{ arch_map[ansible_architecture] | default(ansible_architecture) }}/stable"
            gpgcheck: yes
            gpgkey: https://download.docker.com/linux/centos/gpg
            enabled: yes
        become: yes

        - name: Enable Docker in amazon-linux-extras (Amazon Linux)
        when: ansible_distribution == 'Amazon'
        command: amazon-linux-extras install docker -y
        args:
            creates: /usr/bin/docker
        become: yes

        - name: Install Docker engine (Debian)
        when: ansible_os_family == 'Debian'
        apt:
            name:
            - docker-ce={{ effective_docker_version | default('latest') }}
            - docker-ce-cli={{ effective_docker_version | default('latest') }}
            - containerd.io
            state: present
        register: docker_install_debian
        notify: restart docker
        become: yes

        - name: Install Docker engine (RHEL/CentOS)
        when: ansible_os_family == 'RedHat' and ansible_distribution != 'Amazon'
        yum:
            name:
            - docker-ce={{ docker_ce_version }}
            - docker-ce-cli={{ docker_ce_version }}
            - containerd.io
            state: present
        register: docker_install_rhel
        notify: restart docker
        become: yes

        - name: Ensure docker service is enabled and started
        service:
            name: docker
            state: started
            enabled: yes
        become: yes

        - name: Try to install docker-compose plugin (Debian)
        when: ansible_os_family == 'Debian' and docker_compose_plugin
        apt:
            name: docker-compose-plugin
            state: present
        register: docker_compose_pkg
        failed_when: false
        become: yes

        - name: Try to install docker-compose plugin (RHEL/CentOS)
        when: ansible_os_family == 'RedHat' and ansible_distribution != 'Amazon' and docker_compose_plugin
        yum:
            name: docker-compose-plugin
            state: present
        register: docker_compose_pkg
        failed_when: false
        become: yes

        - name: Fallback - install docker-compose binary if plugin not available
        when: docker_compose_plugin and (docker_compose_pkg is failed or docker_compose_pkg is skipped)
        block:
            - name: Check if docker-compose binary exists
            stat:
                path: /usr/local/bin/docker-compose
            register: docker_compose_binary
            become: yes

            - name: Download docker-compose binary (fallback)
            get_url:
                url: "{{ docker_compose_url }}"
                dest: /usr/local/bin/docker-compose
                mode: '0755'
            when: not docker_compose_binary.stat.exists
            become: yes

            - name: Ensure docker-compose is executable
            file:
                path: /usr/local/bin/docker-compose
                mode: '0755'
            become: yes

        - name: Ensure jenkins user exists
        user:
            name: "{{ jenkins_user }}"
            state: present
            create_home: yes
            shell: /bin/bash
        become: yes

        - name: Check if jenkins user exists
        getent:
            database: passwd
            key: "{{ jenkins_user }}"
        register: jenkins_user_check
        failed_when: false
        become: no

        - name: Add jenkins user to docker group
        when: jenkins_user_check.getent_passwd is defined
        user:
            name: "{{ jenkins_user }}"
            groups: docker
            append: yes
        notify: restart jenkins
        become: yes

        - name: Ensure AWS CLI is executable by all
        file:
            path: /usr/local/bin/aws
            mode: '0755'
        become: yes

        # -----------------------
        # AWS CLI v2
        # -----------------------
        - name: Check installed AWS CLI version
        command: /usr/local/bin/aws --version
        register: aws_ver_check
        changed_when: false
        failed_when: false
        become: no

        - name: Download AWS CLI v2 installer zip
        when: aws_ver_check.rc != 0 or awscli_version not in aws_ver_check.stdout
        get_url:
            url: "{{ awscli_zip_url }}"
            dest: "/home/{{ ansible_user }}/awscliv2.zip"
            mode: '0644'
        become: no

        - name: Unzip AWS CLI installer
        when: aws_ver_check.rc != 0 or awscli_version not in aws_ver_check.stdout
        unarchive:
            src: "/home/{{ ansible_user }}/awscliv2.zip"
            dest: "/home/{{ ansible_user }}"
            remote_src: yes
        become: no

        - name: Install AWS CLI v2
        when: aws_ver_check.rc != 0 or awscli_version not in aws_ver_check.stdout
        command: "/home/{{ ansible_user }}/aws/install"
        args:
            creates: /usr/local/bin/aws
        become: yes

        - name: Clean up AWS CLI installer files
        when: aws_ver_check.rc == 0 and awscli_version in aws_ver_check.stdout
        file:
            path: "{{ item }}"
            state: absent
        loop:
            - "/home/{{ ansible_user }}/awscliv2.zip"
            - "/home/{{ ansible_user }}/aws"
        become: no

        - name: Verify aws is executable
        command: /usr/local/bin/aws --version
        register: aws_ver
        changed_when: false
        failed_when: aws_ver.rc != 0
        become: no

        - name: Debug aws verification failure
        debug:
            msg: "Failed to verify aws cli: {{ aws_ver.stderr | default('No stderr available') }}"
        when: aws_ver.rc != 0
        become: no

        # -----------------------
        # Final sanity checks as jenkins user
        # -----------------------
        - name: Verify docker command as jenkins user
        become_user: "{{ jenkins_user }}"
        command: docker --version
        register: docker_ver
        changed_when: false
        failed_when: false
        when: jenkins_user_check.getent_passwd is defined
        become: yes

        - name: Debug docker verification failure as jenkins user
        debug:
            msg: "Failed to verify docker as {{ jenkins_user }}: {{ docker_ver.stderr | default('No stderr available') }}"
        when: jenkins_user_check.getent_passwd is defined and docker_ver is defined and docker_ver.rc != 0
        become: no

        - name: Verify aws cli as jenkins user
        become_user: "{{ jenkins_user }}"
        command: /usr/local/bin/aws --version
        register: aws_j_ver
        changed_when: false
        failed_when: false
        when: jenkins_user_check.getent_passwd is defined
        become: yes

        - name: Debug aws cli verification failure as jenkins user
        debug:
            msg: "Failed to verify aws cli as {{ jenkins_user }}: {{ aws_j_ver.stderr | default('No stderr available') }}"
        when: jenkins_user_check.getent_passwd is defined and aws_j_ver is defined and aws_j_ver.rc != 0
        become: no

    handlers:
        - name: apt_update
        apt:
            update_cache: yes
        become: yes

        - name: restart docker
        service:
            name: docker
            state: started
        when: docker_install_debian.changed or docker_install_rhel.changed
        become: yes

        - name: restart jenkins
        service:
            name: "{{ jenkins_service_name }}"
            state: restarted
        become: yes
   ```
3. Runt the playbook 
   ```bash
   ansible-playbook -i ansible/inventories/jenkins.ini ansible/playbooks/jenkins_prepare_node.yml
   ```


### 8. Commit & Push to Github

```bash
git add ansible/*
git commit -m "Jenkins Installed via Ansible & Configured"
git push origin ansible-jenkins-setup
```

### 9. PR & Merge

* Open PR → Title: `Jenkins Installed via Ansible & Configured`
* Request review, approve, merge into `main`.



## Checkpoint / Validation

* Playbook run completed and printed the `initialAdminPassword` (or indicated password already set).
* You can access Jenkins UI at `http://<jenkins_public_ip>:8080`.
* You were able to unlock Jenkins with the printed password and create the admin user.
* Plugins installed (either via UI or CLI) and Jenkins restarted successfully.

---

## Troubleshooting Tips

* `initialAdminPassword` not found → either setup already completed (admin user exists) or `init.groovy.d` created an account. If setup already completed, log in with the created admin credentials.
* Jenkins fails to start → check `sudo journalctl -u jenkins -b --no-pager -n 200` for errors. Common causes: wrong Java version (need Java 17/21), broken Groovy init scripts, ownership issues.
* Java error: ensure `openjdk-17-jdk` installed and `/etc/default/jenkins` has `JAVA_HOME="/usr/lib/jvm/java-17-openjdk-amd64"`.
* SSH auth errors: ensure private key has `chmod 600` and inventory uses `ansible_user=ubuntu`.
* Plugin install fails due to network/timeouts: use server-local CLI or offline `.hpi` uploads.

---

## Deliverables (what to commit / submit)

* `ansible/playbooks/jenkins_install_and_show_password.yml` (playbook).
* `ansible/inventories/jenkins.ini` (careful — does not contain secrets).
* (Optional) `ansible/playbooks/plugins_install_cli.yml` if you used it.
* **Do not commit** any private keys or passwords. Commit only the public key if used by Terraform (`infrastructure/jenkins_id_rsa.pub`).
* Screenshots / evidence: playbook run showing `initialAdminPassword`, Jenkins UI unlocked, list of installed plugins (Manage Plugins).

---

## Reflection Question

Why did we decide to show the `initialAdminPassword` and complete the plugin installation manually (or with CLI after admin exists) rather than fully automating plugin installs on the very first boot? What are the trade-offs (stability, security, repeatability)?

---

✅ Lab 07 - complete — Jenkins is installed, unlocked, and ready to be configured by the team.

